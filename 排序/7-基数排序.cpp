/***********************************************************************
*   Copyright (C) 2019  Yinheyi. <chinayinheyi@163.com>
*   
* This program is free software; you can redistribute it and/or modify it under the terms
* of the GNU General Public License as published by the Free Software Foundation; either 
* version 2 of the License, or (at your option) any later version.

*   Brief:    
*   Author: yinheyi
*   Email: chinayinheyi@163.com
*   Version: 1.0
*   Created Time: 2019年05月11日 星期六 14时00分43秒
*   Modifed Time: 2019年05月11日 星期六 14时49分33秒
*   Blog: http://www.cnblogs.com/yinheyi
*   Github: https://github.com/yinheyi
*   
***********************************************************************/


// 基数排序通常用于对具体多个关键字的对象进行排序，并且每一个关键字的优先级不一样。
// 什么意思呢？
// 例如：时间作为一个待排序的对象，它由三个关键字组成：年/月/日, 年和月和日的优先
// 级是不一样的，年的优先级更高，当年的值大时不需要看月与日的值了。如果对这样的时间
// 对象进行排序，很适合使用基数排序。
//
// 基数排序的思想：对包含不同优先级的关键字的排序对象，使用稳定排序算法先按优先级低
// 的关键字对排序对象进行排序，再按优先级高的关键字对排序对象进行排序，最后就会得到有
// 序序列。
//
// 举例说明：
// 例子1：3位的正整数。对于给定的一个3位的正整数，它的百位数的优先级最高，十位数的优
// 先级次之，个位数的优先级最低,因此:
//
// 		原数列		按个位排序的结果	按十位排序的结果	按百位排序的结果
//		329				720					720					329
//		457				355					329					355
//		657				436					436					436
//		839				457					839					457
//		436				657					355					657
//		720				329					457					720
//		355				839					657					839
//
// 例子2：对时间进行排序
//	原时间序列		按天进行排序		按月进行排序		按年进行排序
//	2019/05/11		1949/10/01			1894/01/01			1894/01/01
//	2018/06/25		1894/01/01			2008/05/04			1949/10/01
//	2012/12/12		2020/10/01			2019/05/11			2008/05/04			
//	2008/05/04		2008/05/04			2018/06/25			2012/12/12
//	1949/10/01		2019/05/11			1949/10/01			2018/06/25
//	1894/01/01		2012/12/12			2020/10/01			2019/05/11
//	2020/10/01		2018/06/25			2012/12/12			2020/12/12
//
//
// 说明几点：
// 1. 在基数排序中，对关键字进行排序时必须使用稳定排序算法;
// 2. 一定是从优先级低的关键字向优先级高的关键字进行排起。
// 3. 基数排序的时间复杂度具体取决于你使用的排序算法。
// 4. 如果关键字有一定范围内的话，通常可以使用计数排序算法对关键字进行排序(计数排序是稳定的排序算法）
//
//
// 代码：
// 基数排序不好写代码, 要根据具体的排序对象来决定。
// 它原理很简单，不写代码了。
void RadixSort()
{
}

/***************    main.c     *********************/
int main(int argc, char* argv[])
{
	RadixSort();
	return 0;
}

